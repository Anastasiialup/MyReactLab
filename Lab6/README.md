Документація до проєкту "User Management App" (Реалізація найкращих практик компонентно-орієнтованого програмування на базі React)

- Опис проєкту

Цей проєкт представляє собою веб-застосунок для управління користувачами. Він дозволяє додавати, фільтрувати, сортувати та видаляти користувачів. Реалізовано використання найкращих практик компонентно-орієнтованого програмування на базі бібліотеки React, зокрема, використання мемоїзації, контексту, а також організації коду.

Проєкт реалізовано на основі лабораторних робіт, із використанням атомів стану через бібліотеку Jotai для зберігання та управління користувачами.

- Структура застосунку

atoms/
usersAtom.js: Атом для зберігання стану користувачів, створений за допомогою бібліотеки Jotai.

components/
AddUser.jsx: Компонент для форми додавання користувачів. Містить функцію для додавання нового користувача в загальний список.
UserList.jsx: Компонент для відображення списку користувачів. Він отримує список і передає кожен елемент в компонент UserItem.
UserItem.jsx: Компонент для відображення кожного користувача в списку. Включає кнопку для видалення.
FilterBar.jsx: Компонент для фільтрації користувачів за іменем. Включає інтерфейс для пошуку.

hooks/
useLocalStorage.js: Кастомний хук для роботи з localStorage, який дозволяє зберігати та отримувати дані між сесіями.

utils/
localStorage.js: Допоміжні функції для взаємодії з localStorage (наприклад, функції для збереження та завантаження даних користувачів).

styles/
styles.css: Стилі для оформлення компонентів і структури застосунку.

App.jsx: Головний компонент, який об'єднує інші компоненти та управляє їх станом, фільтрацією, сортуванням та збереженням даних.

main.jsx: Точка входу застосунку. Тут підключається компонент App.

index.html: Шаблон HTML для запуску застосунку в браузері.

Ця структура дозволяє добре організувати проект, зробити код модульним, і забезпечує гнучкість для подальшого розширення функціоналу.

- Використані найкращі практики

1. Використання мемоїзації для оптимізації рендерингу (useMemo)
- Практика: Мемоїзація використовується для оптимізації процесу сортування списку користувачів. Це дозволяє уникнути непотрібних перерахунків списку при кожному оновленні компонентів, що підвищує ефективність застосунку.
- Реалізація: У компоненті `App.js` мемоїзація застосована до списку користувачів, який сортується за вибраним методом (ім'я або дата додавання).
```js
const sortedUsers = useMemo(() => {
    const sorted = [...filteredUsers];
    if (sortMethod === "name") {
        sorted.sort((a, b) => a.name.localeCompare(b.name));
    } else if (sortMethod === "date") {
        sorted.sort((a, b) => b.createdAt - a.createdAt);
    }
    return sorted;
}, [filteredUsers, sortMethod]);
```

2. Використання атомів для управління станом (Jotai)
- Практика:Замість використання глобального стану або контексту, застосунок використовує бібліотеку **Jotai** для зберігання стану користувачів у вигляді атома.
- Реалізація: Атом `usersAtom` визначений у файлі `atoms/usersAtom.js`, а його значення оновлюються в компоненті `App.js`.
```js
import { atom } from 'jotai';

export const usersAtom = atom([]);
```

3. Розділення коду на компоненти
- Практика: Застосунок побудований за принципом компонентно-орієнтованого програмування, де кожен компонент відповідає за свою конкретну функціональність. Це забезпечує гнучкість і зручність у підтримці проєкту.
- Реалізація: Компоненти для додавання користувачів, фільтрації, відображення списку користувачів і кнопок видалення кожен реалізований окремо, що дозволяє ізолювати бізнес-логіку і стиль.
```js
// AddUser.js
const AddUser = ({ addUser }) => {
    // Код для додавання користувача
};
```

4. Використання локального зберігання для збереження стану
- Практика: Для збереження стану користувачів між сесіями використовується localStorage. Це дозволяє зберігати список користувачів після перезавантаження сторінки.
- Реалізація: У компоненті `App.js` дані користувачів зберігаються в `localStorage` після кожної зміни.
```js
useEffect(() => {
    const savedUsers = JSON.parse(localStorage.getItem("users"));
    if (savedUsers) {
        setUsers(savedUsers);
    }
}, []);

useEffect(() => {
    localStorage.setItem("users", JSON.stringify(users));
}, [users]);
```

5. Оптимізація оновлення компонентів за допомогою useEffect
- Практика: Використання useEffect для ініціалізації даних з `localStorage` при першому завантаженні сторінки і для синхронізації стану користувачів з `localStorage`.
- Реалізація: У компоненті `App.js` використано два хука `useEffect` для відновлення даних з `localStorage` при монтуванні компонента та для запису в `localStorage` при зміні користувачів.
```js
useEffect(() => {
    const savedUsers = JSON.parse(localStorage.getItem("users"));
    if (savedUsers) {
        setUsers(savedUsers);
    }
}, []);

useEffect(() => {
    localStorage.setItem("users", JSON.stringify(users));
}, [users]);
```

6. Адаптивний дизайн для забезпечення зручного перегляду на мобільних пристроях
- Практика: Використання медіа-запитів для забезпечення адаптивності інтерфейсу застосунку на різних розмірах екранів.
- Реалізація: У стилях CSS використані медіа-запити для коректного відображення елементів на мобільних пристроях.
```css
@media (max-width: 600px) {
    .app-container {
        padding: 10px;
    }
    input, select {
        width: 100%;
    }
}
```

- Підсумки
  Всього у проєкті реалізовано 6 практик:
1. Мемоїзація для сортування
2. Використання атомів для управління станом
3. Розділення коду на компоненти
4. Локальне зберігання даних
5. Оптимізація оновлення за допомогою `useEffect`
6. Адаптивний дизайн


- Примітки:
- Кожна найкраща практика описана та реалізована у проєкті.
- Код є модульним та зрозумілим, що дозволяє легко додавати нові функціональності в майбутньому.